## MQ是什么

MQ（Message Queue）消息队列

+ 是基础数据结构中 `先进先出` 的一种数据结构。
+ 是一种 `跨进程的通信机制`，用于上下游传递消息。

> 在互联网架构中，MQ 是一种非常常 见的上下游“`逻辑解耦+物理解耦`”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。



## MQ 作用

一般用来解决应用解耦，异步消息，流量削峰等问题，实现高性能，高可用，可伸缩和最终一致性架构。

+ 流量消峰
  + 高并发情况下，业务异步处理，提供高峰期业务处理能力，避免系统瘫痪。
+ 应用解耦
  + 一个业务需要多个模块共同实现，或者一条消息有多个系统需要对应处理，只需要主业务完成以后，发送一条MQ，其余模块消费MQ消息，即可实现业务，降低模块之间的耦合。
+ 异步处理
  + 主业务执行结束后从属业务通过MQ，异步执行，减低业务的响应时间，提高用户体验。

MQ的缺点

+ 系统可用性降低。依赖服务也多，服务越容易挂掉。需要考虑MQ瘫痪的情况
+ 系统复杂性提高。需要考虑消息丢失、消息重复消费、消息传递的顺序性
+ 业务一致性。主业务和从属业务一致性的处理

## MQ 产品

+ `ActiveMQ`
  + 优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据 
  + 缺点:官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。
+ `Kafka`
  + **大数据** 而生的消息中间件，百万级 TPS 的吞吐量
  + 优点: 
    + 性能卓越，单机写入 TPS 约在百万条/秒，最大的优点，就是吞吐量高。
    + 时效性 ms 级可用性非 常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采 用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;
    + 有优秀的第三方 Kafka Web 管理界面 Kafka-Manager；
    + 在日志领域比较成熟，被多家公司和多个开源项目使用；
    + 功能支持： 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用 
  + 缺点：
    + Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消 息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；
    + 支持消息顺序， 但是一台代理宕机后，就会产生消息乱序
    + **社区更新较慢；**
+ `RocketMQ`
  + RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。
  + 优点：单机吞吐量十万级,可用性非常高，分布式架构,消息可以做到 0 丢失,MQ 功能较为完善，还是分布式的，扩展性好,支持 10 亿级别的消息堆积，不会因为堆积导致性能下降,源码是 java 我们可以自己阅读源码，定制自己公司的 MQ
  + 缺点：支持的客户端语言不多，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在 MQ
    核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码

+ `RabbitMQ`
  + 2007 年发布，是一个在 **AMQP**(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。
  + 优点：由于 **erlang 语言** 的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备,健壮、稳定、易用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高
  + 缺点：商业版需要收费,学习成本较高



## AMQP 协议	

### AMQP是什么

`AMQP`（高级消息队列协议）一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计



### AMQP 0-9-1 模型简介

消息（message）被`发布者`（publisher）发送给 `交换机`（exchange），交换机常常被比喻成邮局或者邮箱。然后交换机将收到的消息根据 `路由` 规则分发给绑定的 `队列`（queue）。最后AMQP代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。

![hello-world-example-routing](../../../_media/hello-world-example-routing.png)

发布者（publisher）发布消息时**可以给消息指定各种消息属性**（message meta-data）。有些属性有可能会被消息代理（brokers）使用，然而其他的属性则是完全不透明的，它们只能被接收消息的应用所使用。

从安全角度考虑，网络是不可靠的，接收消息的应用也有可能在处理消息的时候失败。基于此原因，AMQP模块包含了一个消息确认（message acknowledgements）的概念：当一个消息从队列中投递给消费者后（consumer），消费者会通知一下消息代理（broker），这个可以是自动的也可以由处理消息的应用的开发者执行。当“消息确认”被启用的时候，消息代理不会完全将消息从队列中删除，直到它收到来自消费者的确认回执（acknowledgement）。

在某些情况下，例如当一个消息无法被成功路由时，消息或许会被返回给发布者并被丢弃。或者，如果消息代理执行了延期操作，消息会被放入一个所谓的 **死信队列** 中。此时，消息发布者可以选择某些参数来处理这些特殊情况。

**队列，交换机和绑定统称为AMQP实体（AMQP entities）。**



### 交换机和交换机类型

交换机是用来发送消息的AMQP实体。交换机拿到一个消息之后将它路由给一个或零个队列。它使用哪种路由算法是由交换机类型和被称作绑定（bindings）的规则所决定的。AMQP 0-9-1的代理提供了四种交换机

| Name（交换机类型）            | Default pre-declared names（预声明的默认名称） |
| :---------------------------- | :--------------------------------------------- |
| Direct exchange（直连交换机） | (Empty string) and amq.direct                  |
| Fanout exchange（扇型交换机） | amq.fanout                                     |
| Topic exchange（主题交换机）  | amq.topic                                      |
| Headers exchange（头交换机）  | amq.match (and amq.headers in RabbitMQ)        |

除交换机类型外，在声明交换机时还可以附带许多其他的属性，其中最重要的几个分别是：

- `Name`
- `Durability` （消息代理重启后，交换机是否还存在）
- `Auto-delete` （当所有与之绑定的消息队列都完成了对此交换机的使用后，删掉它）
- `Arguments`（依赖代理本身）

交换机可以有两个状态：`持久`（durable）、`暂存`（transient）。

+ 持久化的交换机会在消息代理（broker）重启后依旧存在

+ 暂存的交换机则不会（它们需要在代理再次上线后重新被声明）。

  > 然而并不是所有的应用场景都需要持久化的交换机。



#### 默认交换机

+ **实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机。**
+ 有一个特殊的属性：每个新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。

#### 直连交换机

+ 是根据消息携带的 `路由键`（routing key）将消息投递给对应队列的。
+ 用来处理消息的 `单播路由`（unicast routing）（尽管它也可以处理多播路由）。
+ 工作原理：
  + 将一个队列绑定到某个交换机上，同时赋予该绑定一个 **路由键**（routing key）
  + 当一个携带着路由键为 `R` 的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为 `R`的队列。

+ 直连交换机经常用来循环分发任务给多个工作者（workers）。在AMQP 0-9-1中，消**息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。**



#### 扇型交换机

+ 将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。
+ 扇型交换机投递消息的拷贝到所有绑定到它的队列。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。
+ 扇型用来交换机处理消息的 `广播路由`（broadcast routing）。

+ 使用案例：
  + 大规模多用户在线（MMO）游戏可以使用它来处理排行榜更新等全局事件
  + 体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端
  + 分发系统使用它来广播各种状态和配置更新
  + 在群聊的时候，它被用来分发消息给参与群聊的用户。（AMQP没有内置presence的概念，因此XMPP可能会是个更好的选择）



#### 主题交换机

+ 通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。
+ 经常用来实现各种 分发/订阅 模式及其变种。
+ 常用来实现消息的 `多播路由`（multicast routing）。
+ 当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者/多应用（multiple consumers/applications） 的时候可以使用主题交换机
  + 分发有关于特定地理位置的数据，例如销售点
  + 由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务
  + 股票价格更新（以及其他类型的金融数据更新）
  + 涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）
  + 云端的不同种类服务的协调
  + 分布式架构/基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统。



#### 头交换机

+ 头交换机使用多个消息属性来代替路由键建立路由规则。
+ 通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。



### 队列

+ AMQP中的队列（queue）跟其他消息队列或任务队列中的队列是很相似的：它们存储着即将被应用消费掉的消息。队列跟交换机共享某些属性，但是队列也有一些另外的属性。
  - `Name`
  - `Durable`（消息代理重启后，队列依旧存在）
  - `Exclusive`（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）
  - `Auto-delete`（当最后一个消费者退订后即被删除）
  - `Arguments`（一些消息代理用他来完成类似与TTL的某些额外功能）
+ 队列在声明（declare）后才能被使用。
  + 如果一个队列尚不存在，声明一个队列会创建它。
  + 如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。
  + 如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为406的通道级异常就会被抛出。



#### 队列名称

+ 队列的名字可以由应用（application）来取，也可以让消息代理（broker）直接生成一个。
+ 队列的名字可以是最多 `255` 字节的一个 `utf-8` 字符串。
+ 用AMQP消息代理生成队列名，需要给队列的name参数赋值一个空字符串：在同一个通道（channel）的后续的方法（method）中，可以使用空字符串来表示之前生成的队列名称。之所以之后的方法可以获取正确的队列名是因为通道可以默默地记住消息代理最后一次生成的队列名称。
+ 以”`amq.`”开始的队列名称被预留做消息代理内部使用。如果试图在队列声明时打破这一规则的话，一个通道级的403 (ACCESS_REFUSED)错误会被抛出。



#### 队列持久化

+ 持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。
+ 没有被持久化的队列称作暂存队列（Transient queues）。并不是所有的场景和案例都需要将队列持久化。

> 持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。



### 绑定

+ 绑定（Binding）是 交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。
  + 如果要指示交换机“E”将消息路由给队列“Q”，那么“Q”就需要与“E”进行绑定。
+ 绑定操作需要定义一个可选的 `路由键`（routing key）属性给某些类型的交换机。
  + 路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。



### 消费者

消息如果只是存储在队列里是没有任何用处的。被应用消费掉，消息的价值才能够体现。在AMQP 0-9-1 模型中，有两种途径可以达到此目的：

- 将消息投递给应用 (“push API”)
  + 需要明确表示出它在某个特定队列里所感兴趣的，想要消费的消息。
  + 一个队列可以注册多个消费者
  + 也可以注册一个独享的消费者（当独享消费者存在时，其他消费者即被排除在外）。
- 应用根据需要主动获取消息 (“pull API”)

每个消费者（订阅者）都有一个叫做消费者标签的标识符。它可以被用来退订消息。消费者标签实际上是一个字符串。



#### 消息确认

消费者应用：用来接受和处理消息的应用 

在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题。AMQP代理在什么时候删除消息才是正确的？AMQP 0-9-1 规范给我们两种建议：

- 当消息代理（broker）将消息发送给应用后立即删除。
  + 使用AMQP方法：`basic.deliver` 或 `basic.get-ok`
  + 称作 `自动确认` 模式（automatic acknowledgement model）
- 待应用（application）发送一个确认回执（acknowledgement）后再删除消息。
  + 使用AMQP方法：`basic.ack`
  + 称作 `显式确认` 模式（explicit acknowledgement model）。
  + 由消费者应用来选择什么时候发送确认回执。
    + 可以在收到消息后立即发送
    + 或将未处理的消息存储后发送
    + 或等到消息被处理完毕后再发送确认回执（例如，成功获取一个网页内容并将其存储之后）。
  + 如果一个消费者在尚未发送确认回执的情况下挂掉了，那AMQP代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。



#### 拒绝消息

当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。

应用可以向消息代理表明，本条消息由于“拒绝消息（Rejecting Messages）”的原因处理失败了（或者未能在此时完成）。

当拒绝某条消息时，应用可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列。

**当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生。**



#### Negative Acknowledgements

在AMQP中，`basic.reject` 方法用来执行拒绝消息的操作。但basic.reject有个限制：不能使用它拒绝多个带有确认回执（acknowledgements）的消息。但是如果使用的是RabbitMQ，那么可以使用被称作negative acknowledgements（也叫nacks）的AMQP 0-9-1扩展来解决这个问题。



#### 预取消息

在多个消费者共享一个队列的案例中，明确指定在收到下一个确认回执前每个消费者一次可以接受多少条消息是非常有用的。这可以在试图批量发布消息的时候起到简单的负载均衡和提高消息吞吐量的作用。For example, if a producing application sends messages every minute because of the nature of the work it is doing.（？？？例如，如果生产应用每分钟才发送一条消息，这说明处理工作尚在运行。）

注意，RabbitMQ只支持通道级的预取计数，而不是连接级的或者基于大小的预取。



### 消息属性和有效载荷（消息主体）

AMQP模型中的消息（Message）对象是带有属性（Attributes）的。有些属性及其常见，AMQP 0-9-1 明确的定义了它们

+ Content type（内容类型）
+ Content encoding（内容编码）
+ Routing key（路由键）
+ Delivery mode (persistent or not)：投递模式（持久化 或 非持久化）
+ Message priority（消息优先权）
+ Message publishing timestamp（消息发布的时间戳）
+ Expiration period（消息有效期）
+ Publisher application id（发布应用的ID）



