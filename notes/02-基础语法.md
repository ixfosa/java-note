## 注释

注释就是使用文字对程序的说明，注释是写给程序员看的，编译器会忽略注释的 内容的。

1.  注释的类别

   + 第一种： 单行注释。   `// 注释的内容`
   + 第二种： 多行注释。   `/* 注释的内容  */`
   + 第三种： 文档注释.     `/** 注释的内容  */`

   > 注释要注意的细节：
   >
   > 单行注释可以嵌套使用，多行注意是不能嵌套使用的。



2. 注释的作用
   + 使用文字对程序说明。
   + 调试程序



3. 文档注释与多行注释的区别

   + 多行注释与文档注释的区别： 多行注释的内容不能用于生成一个`开发者文档`，
     而文档注释 的内容可以生产一个开发者文档。

   

4. 使用`javadoc`开发工具即可生成一个开发者文档。

   + `javadoc`工具的使用格式：
     + `javadoc -d `   存放文档的路径 java 的源文件 

   > 使用javadoc工具要注意细节：
   >
   > 1. 如果一个类需要使用javadoc工具生成一个软件的开发者文档，那么该类必须使用`public`修饰。
   > 2. 文档注释注释的内容一般都是位于类或者方法的上面的。



**若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。**



## 标识符和关键字

### 标识符

在java程序中有些名字是可以`自定义`的，那么这些自定义的名字就称作为`自定义的标识符`。

1. 标识符要注意的细节
   + 标识符的组成元素是由 字母（`a-zA-Z`） 、数字(`0-9`) 、 下划线(`_`)、 美元符号(`$`).
     + 标识符`不能以数字开头`。
     + 标识符是`严格区分大小写`的。
     + 标识符的长度是没有长度限制的。
     + 标识符的命名一般要有意义（要做到让人`见名知意`）
     + 关键字、保留字不能用于自定义的标识符。



2. 自定义标识符的规范
   1. `类名`和`接口名`单词的`首字母大写`，`其他单词小写`。 比如： RunTime.
   2. `变量名`与`方法名` `首单词全部小写`，`其他单词首字母大写`，`其他小写`。  比如： doCook()；
   3. `包名全部单词小写`。
   4. `常量全部单词大写`，单词与单词之间使用`下划线`分隔。  比如： UP_DIRECTION



3. 判断一下那些是 符合的标识符
   + 12abc_       不合法  数字不能开头
   + _12abc       合法
   + $ab12#       不合法  #号不属于标识符组成元素。
   + abc@123   不合法  @号不属于标识符组成元素。 



### 关键字

**关键字**：关键字就是在java程序中具备`特殊含义的标识符`。关键字一般用于描述一个程序的结构或者表示数据类型。

|                      |          |            |          |              |            |           |        |
| :------------------: | -------- | ---------- | -------- | ------------ | ---------- | --------- | ------ |
|       访问控制       | private  | protected  | public   |              |            |           |        |
| 类，方法和变量修饰符 | abstract | class      | extends  | final        | implements | interface | native |
|                      | new      | static     | strictfp | synchronized | transient  | volatile  |        |
|       程序控制       | break    | continue   | return   | do           | while      | if        | else   |
|                      | for      | instanceof | switch   | case         | default    |           |        |
|       错误处理       | try      | catch      | throw    | throws       | finally    |           |        |
|        包相关        | import   | package    |          |              |            |           |        |
|       基本类型       | boolean  | byte       | char     | double       | float      | int       | long   |
|                      | short    | null       | true     | false        |            |           |        |
|       变量引用       | super    | this       | void     |              |            |           |        |
|        保留字        | goto     | const      |          |              |            |           |        |

#### 访问权限修饰符

- `private`（当前类访问权限）：在同一类内可见，只能被所属类访（包访问权限）：不使用任何修饰符时，在同一包内可见
- `protected`（子类访问权限）：对同一包内的任何其它类和不同包中的子类可见，不能修饰接口中的成员变量和成员方法（注意：在**不同包中的子类**只能通过**该子类**访问父类中 `protected` 成员，通过其它子类或父类都无法访问）
- `public`（公共访问权限）：对所有类可见



#### 非访问修饰符

- `static` 用来创建类方法和类变量，类方法**不能访问**的实例变量
- `final` 用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，不可修改
- `abstract` 用来创建抽象类、抽象方法
- `synchronized` 修饰的方法、代码块在同一时间只能被一个线程访问，不能修饰构造器、成员变量等
- `volatile` 修饰的**成员变量**在**每次**被线程访问时，都强迫从**共享内存**中重读该成员变量的值；并且，当成员变量发生变化时，强迫线程将变化值回写到共享内存（保证了线程操作时变量的**可见性**，即一个线程修改了某个变量的值，这新值对其它线程来说是立即可见的）（只能保证内存可见性，无法保证操作的原子性）
- `transient` 序列化的对象包含被 transient 修饰的实例变量时，JVM 跳过该特定的变量
- `native` 修饰的方法通常采用 C/C++ 语言来实现



#### volatile 的实现原理

- 如果对声明了 volatile 变量进行写操作，JVM 就会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写回到内存，这个写回内存的操作会引起在其它 CPU 里缓存了该内存地址的数据无效
- 缓存一致性协议（如 Intel 的 MESI 协议）：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里



## 常量和变量

### 常量

**常量就是程序在运行过程中其值不能发生改变的量。**

1. 常量的类别：

   + 整数常量：        10
   + 小数常量：	    3.14
   + 布尔常量：        布尔常量只有两个值： `true`(正确). `false`(错误)
   + 字符常量：        字符常量就是单个字符使用单引号引起来的内容我们称作为字符常量。
   + 字符串常量：    字符串常量就是使用双引号引起来的内容称作为字字符串常量。

   > 整数常量的表现形式：整数的表现形式主要是以不同的进制(二进制、八进制、十六进制)表现出来。

```java
class Demo{
	public static void main(String[] args){
		System.out.println(12);    // 整数常量
		System.out.println(3.14);  // 小数常量
		System.out.println(false); // 布尔常量
		System.out.println('1');   // 字符常量
		System.out.println("hello world");  // 字符串常量

		// 如果一个数据没有加上任何的标识之前，默认就是十进制的数据。
		System.out.println(10);   // 十进制  10
		System.out.println(0b10); // 二进制 2
		System.out.println(010);  // 八进制数据， 八进制的数据需要以0开头  8 
		System.out.println(0x10); // 十六进制数据， 十六进制的数据需要以0x开头    16
	}
}
```



### 变量

**变量**就是在程序`运行过程`中其值可以`发生变化`的量,     变量就是一个`存储数据的容器`。

1. 容器具备什么特点
   + 容量(大小)
   + 存储一定格式的数据。
   + 名字



2. 声明（定义）一个变量的格式
   - `容量  变量名字 = 数据;`。   int age = 22;
   - **变量名的命名规范： 首单词小写，其他单词首字母大写，其他小写**  



3. 声明变量的方式

   + 声明变量的方式一：
     + `数据类型 变量名;`
   +  声明变量的方式二： 一次性声明了多个相同类型变量
     + `据类型  变量名1, 变量名2...;`

   > 注意：
   >
   > 1. 变量是必须先`声明`再使用。
   > 2. 在一个作用域中不能声明`同名`的变量。  

```java
class Demo {
	public static void main(String[] args) {	
        
		//int age = 12; //声明一个变量
		int age ,height ;  //声明了变量

		//给变量赋值
		age = 10;
		height = 175;
		System.out.println(age);
		System.out.println(height);
	}
}
```



## 基本数据类型及转换

### 基本数据类型

Java中有`8`种基本数据类型，分别为

+ 6种数字类型 ：`byte`、`short`、`int`、`long`、`float`、`double`
+ 1种字符类型：`char`
+ 1种布尔型：`boolean`

> 这八种基本类型都有对应的包装类分别为：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean`
>
> 字符串的数据类型是：`String `引用数据类型,不属于基本数据类型。
>
> `引用类型`变量：类，接口，数组（枚举enum是一种特殊的类），引用型变量实际保存的是对象在`内存`的`地址`。

| 基本类型 | 位数 | 字节 | 默认值  |      |
| :------- | :--- | :--- | ------- | ---- |
| int      | 32   | 4    | 0       |      |
| short    | 16   | 2    | 0       |      |
| long     | 64   | 8    | 0L      |      |
| byte     | 8    | 1    | 0       |      |
| char     | 16   | 2    | 'u0000' |      |
| float    | 32   | 4    | 0f      |      |
| double   | 64   | 8    | 0d      |      |
| boolean  | 1    |      | false   |      |



**布尔类型： 布尔类型只有两个 值，true或者false。**1字节或者4个字节 

+ 如果使用boolean声明一个`基本`类型的变量时，那么该变量占`4`个字节，
+ 如果使用boolean声明一个`数组`类型 的时候，那么每个数组的元素占`1`个字节。

对于`boolean`，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1位，但是实际中会考虑计算机高效存储因素。



> 注意：
>
> 1. Java 里使用 `long` 类型的数据一定要在数值后面加上` L`，否则将作为整型解析：
> 2. `char a = 'h'`char :`单引号`，`String a = "hello"` :`双引号`



> 注意： 
>
> 如果一个整数没有加上任何的标识的时候，那么默认是`int`类型的数据。
> 如果需要把该数据表示成一个`long`类型的数据，那么需要加数据后面加上`L`表示，L是`不区分大小写`的，但是建议使用`大写`。



> 注意： 
>
> 如果一个小数没有加上任何标识的时候，那么该小数默认是`double`类型的数据，如果需要表示成`float`类型，那么需要在小数的后面加上`f`表示。f不区分大小写的。



### 数据类型转换

1. 数据类型转换
   + 小数据类型--------->大数据类型     自动类型转换
   + 大数据类型--------->小数据类型     强制类型转换



2. 强制类型转换的格式
   + `小数据类型  变量名 = (小数据类型)大数据类型`



3. 数据类型转换要注意的细节：
   + 凡是`byte`、`short `、 `char`数据类型数据在运算的时候都会自动转换成`int`类型的数据再运算。
   	2. 两个不同数据类型的数据在运算的时候，结果取决于大的数据类型。

```java
class Demo {
	public static void main(String[] args) {
	
		byte  b=  11;   // 一个字节   
		short s = b;    // 把b变量存储的值赋予给s变量。 2字节 二两的碗
		int i = s;      // i是4字节
		long l = i;     // l 是8个字节。 
		System.out.println(l);
		
		int i = 128;  //4个字节
		byte b =(byte) i;  // 1个字节
		System.out.println(b);  // -128 
		
		// 如果是负数，那么最高位肯定是1， 正数的二进制位的最高位是0。
        // sun提供一个功能 Integer.tobinaryString()  查看一个数据的二进制数据形式的。
		System.out.println(Integer.toBinaryString(-7)); // 11111001（补码）

		//凡是byte、short 、 char数据类型数据在运算的时候都会自动转换成int类型的数据再运算。
		byte b1 =1;
		byte b2 = 2;
		byte b3 = (byte)(b1+b2);
		System.out.println(b3); //3  
		
		System.out.println('a'+1); //98 
				
		// 两个不同数据类型的数据在运算的时候，结果取决于大的数据类型
		int i =10;
		long l = 20;
		i = (int)(i+l); 
		System.out.println(i);

		int i = 10;  
		byte b = i;  // 一个整数没有加上任何标识的时候，默认是int类型的数据。
		// 10 是一个常量， 编译器在编译的时候就能够确认常量的值了，byte b = 10,在编译到的时候
		// java编译器就会检查到10并没有超出byte的表示范围，所以允许赋值。
		// java编译器在编译 的时候并不能确认变量所存储的值，变量存储的值是在运行的时候才在内存中分配  空间的。
		System.out.println(b);
	}
}
```



## 自动装箱与拆箱和常量池

### 装箱与拆箱

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；

```java
public class Main {
    public static void main(String[] args) {
        // 自动装箱
        Integer a = 99;

        // 自定拆箱
        int b = a;
    }
}
```



### 常量池

1. Java 基本类型的包装类的大部分都实现了常量池技术 即

   + `Byte`,`Short`,`Integer`,`Long` 这4 种包装类默认创建了数值`[-128，127]` 的相应类型的缓存数据

   + `Character `创建了数值在`[0,127]`范围的缓存数据
   + `Boolean` 直接返回`True` Or `False`。

   >  如果超出对应范围仍然会去创建新的对象。
   >
   > 为什么把缓存设置为[-128，127]区间？性能和资源之间的权衡。

```java
public static Boolean valueOf(boolean b) {
    return (b ? TRUE : FALSE);
}
```

```java
private static class CharacterCache {         
    private CharacterCache(){}
    static final Character cache[] = new Character[127 + 1];          
    static {
        for (int i = 0; i < cache.length; i++)                 
            cache[i] = new Character((char)i);         
    }   
}
```



2. Integer 缓存源代码：

   ```java
   /**
   *此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。
   */
   public static Integer valueOf(int i) {
       if (i >= IntegerCache.low && i <= IntegerCache.high)
           return IntegerCache.cache[i + (-IntegerCache.low)];
       return new Integer(i);
   }
   ```

   

   **两种浮点数类型的包装类 Float,Double 并没有实现常量池技术**

```java
Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);   // 输出 true

Integer i11 = 333;
Integer i22 = 333;
System.out.println(i11 == i22); // 输出 false

Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);   // 输出 false
```



3. 应用场景

   + `Integer i1=40;`Java 在编译的时候会直接将代码封装成 `Integer i1=Integer.valueOf(40);`，从而使用常量池中的对象。
   + `Integer i1 = new Integer(40);`这种情况下会创建新的对象。

   ```java
   Integer i1 = 40;
   Integer i2 = new Integer(40);
   System.out.println(i1==i2);//输出 false
   ```



4. 例子

   ```java
   Integer i1 = 40;
   Integer i2 = 40;
   Integer i3 = 0;
   Integer i4 = new Integer(40);
   Integer i5 = new Integer(40);
   Integer i6 = new Integer(0);
   
   System.out.println("i1=i2   " + (i1 == i2));
   System.out.println("i1=i2+i3   " + (i1 == i2 + i3));
   System.out.println("i1=i4   " + (i1 == i4));
   System.out.println("i4=i5   " + (i4 == i5));
   System.out.println("i4=i5+i6   " + (i4 == i5 + i6));
   System.out.println("40=i5+i6   " + (40 == i5 + i6));
   
   // 结果：
       i1=i2   true
       i1=i2+i3   true
       i1=i4   false
       i4=i5   false
       i4=i5+i6   true
       40=i5+i6   true
   ```

   > 解释：
   >
   > 语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。
   >
   > 
   >
   > 必须满足两个条件才为true： 
   >
   > 1. 类型相同 
   > 2. 内容相同 

   



## 运算符及优先级

### 算术运算符

算术运算符

+ `+ `  ：正数、加法、连接符
  		连接符的作用： 让任何的数据都可以与字符串进行拼接。
    		如果`+号用于字符串`的时候，那么+号就是一个连接符，并不是 做加法功能了
          连接符要注意：任何类型的数据与字符串使用连接符连接，那么结果都是字符串类型的数据。
+ `-`：减法
+ `*`：乘法
+ `/ ` ：除法
+ `%`：取模、取余数

```java
class Demo {
	public static void main(String[] args){
	
		int i1 = 1;
		int i2 = 2;
		System.out.println(i1 +" world");  //    1 world
		
		// 计算机每次运算的时候只能取两个 数据运算。
		System.out.println(1+2+3 +" world"+1+2+3); // 6 world123

		double a= 12.0;
		int b = 3;
		System.out.println(a/b); // 4.0

		//在java中做取模 运算的时，结果的正负号是取决于被除数。
		System.out.println("结果:"+(10%3));  // 1
		System.out.println("结果:"+(10%-3)); // 1      
		System.out.println("结果:"+(-10%3)); // -1    
		System.out.println("结果:"+(-10%-3)); // -1 
	}
}
```



### 自增和自减

1. 自增
   + `++ `（自增） :  自增就是相当于操作数+1.
     + 前自增：++位于操作数的前面。  比如： ++a；
     + 前自增：先自增，后使用
     + 后自增：++位于操作数的后面。  比如： a++
     + 后自增： 先使用，后自增。

```java
class Demo {
	public static void main(String[] args) {
		
		int a = 0;
		int sum1 = ++a; // 前自增。 a = a+1  ， sum = a
		System.out.println("sum1 = "+ sum1+ " a = "+ a);  // sum1 = 1 a = 1
		int sum2 = a++; // 后自增  sum = 0 , a = a+1
		System.out.println("sum2 = "+ sum2+ " a = "+ a); //sum2 = 1 a = 2

   		// 后自增在jvm的运行原理：
		// 因为后自增要使用 到没有+1之前 的值，那么jvm会先声明一个变量用于保存没有+1之前的值。
		// int i = 0;
		// i = temp;

		/*原理：
			1. int temp = i; // 声明了一个临时变量用于记录了i没有加1之前的值。
			2. 自增。  i = i+1;   i = 1;
			3. temp用作了表达式的结果。
	
			i的值发生了几次变化：
			i = 0 -----> 1----> 0
         */

		int i = 0;
		i = i++; // 后自增...  后自增要使用到没有+1之前的值。
		System.out.println("i= "+i);   //0
	}
}
```



2. 自减
   + 自减： 操作数-1
     + 前自减: --位于操作数的前面。  --操作数
     + 前自减： 先自减，后使用
     + 后自减：--位于操作数的后面。 操作数--；
     + 后自减： 先使用，后自减。

```java
class Demo {
	public static void main(String[] args) {	
		/*
		int i = 1;
		int sum = --i;  //前自减   i = i-1 , sum = i;
		int sum = i--; // 后自减   sum = i ; i = i-1;
		System.out.println("sum = "+ sum);  // 0  1 
		*/

		int num = 10;
		//int sum = 10* num++; // 后自增
		int sum = 10* ++num;   // 前自增 
		System.out.println("sum = "+ sum);  //110
	}
}
```



### 赋值运算符

赋值运算符：

+ `= `  
+ `+= `
+ `-=`
+ `*=`
+ ``/=``
+ `%=`

```java
class Demo {
	public static void main(String[] args) {
		
		int i = 10; // 把10赋予给i变量。
		i+=2;       // i = i+2; 
		System.out.println("i = "+i);  //12
	
		byte b1 = 1;
		byte b2 = 2;
		// b2 = b2+b1; //报错。需要强制类型转换 错误: 不兼容的类型: 从int转换到byte可能会有损失
		// b2 = (byte)(b2+b1);
		
		b2+=b1;       
        //b2 = b2+ b1;	 b2+=b1 在编译的时候，java编译器会进行强制类型转换，不需要我们手动转换
		System.out.println("b2 : "+ b2);  //3
	}
}
```



### 比较运算符

比较运算符： 比较运算符的结果都是返回一个`布尔值`的。

+ `==`：判断是否等于
  + ==用于比较两个**基本数据类型数据**的时候，比较的是两个变量所**存储的值**是否一致.
  + ==用于比较两个**引用类型变量的数据**时候，比较的是两个 引用类型变量所记录的**内存地址是否一致**. 
+ `>`：大于
+ `<`：小于
+ `!= `：不等于
+ `>=`：大于等于
+ `<=`：小于等于

```java
class Demo {
	public static void main(String[] args) {
		int a = 10;
		int b =10;
		System.out.println("10等于10吗？"+ (a==b));  //true  
		System.out.println("10不等于1吗？"+ (10!=1) ); //true  

		byte c  = 10;
		long l = 30;
		System.out.println(l>c); // true 两个不同类型的数据是否可以比较,可以的，但是两个不                                      // 同类型的数据必须是兼用的数据。
		//这个比较的过程会先把b转换了long类型的数据，然后再进行比较。
		System.out.println('a'>50); //true  
	}
}
```

### 位运算符

位运算符：位运算符就是直接操作二进制位的。

+ `& `：与
+ `| `：或
+ `^`：异或
+ `~`：取反

> 规律： 如果操作数A连续`异或`同一个操作数`两次`，那么结果还是操作数A。
>
> 应用： 对数据加密.

```java
class Demo{
	public static void main(String[] args){
		System.out.println(6&3); // 2 
		System.out.println(6|3); // 7
		System.out.println(6^3); //  5
		System.out.println(~7);  // -8
	}
}
```

![alt 位运算](_media/位运算符.png)



### 逻辑运算符

逻辑运算符 ：逻辑运算符的**作用是用于连接布尔表达式**的。 

+ `& `（与,并且）

  + 规律： 只有左右变量同时 为true，那么结果才是true，否则就为false。

+ `|`  (或,或者)

  + 规律： 只要两边的布尔表达式有一边为true，那么结果就为true，只有两边同时为false 的时候，结果才是false.

+ `^ ` (异或)

  + 规律： 只要两边的布尔表达式 结果不一致，那么结果就为true，如果左右两边 的布尔表达式一致，那么就为false.

+ `！` (非)

+ `&&` (短路与\双与)

+ `|| `(短路或\双或)

  

`短路与`和`单与`符号的相同与不同点：

+ 相同点： 短路与和单与运算 的结果是一样的。

+ 不同点： 使用短路与的时候，如果左边的布尔表达式为false，则不会在运算右边的布尔表达式，从而提高了效率。使用单与的时候，即使发现左边的布尔表达式为false，还是会运算右边的布尔表达式的。

  > 只有左边的布尔表达式为false时，双与的效率才要高于单与的.



`短路或`与`单或`的相同点与不同点：

+ 相同点：运算的结果是一致 的。

+ 不同点：使用短路或的时候，当发现左边的布尔表达式为true时，则不会运算右边的布尔表达式。

  > 使用单或的时候 发现左边的布尔表达式为true，还是会运算右边布尔表达式 

```JAVA
class Demo {
	public static void main(String[] args) {
	
		int workAge = 2;
		int age = 24;
		System.out.println(workAge>=2|age++>18);
		System.out.println("age:"+ age);
		
		
		System.out.println(true&true);   //true
		System.out.println(true&false);  // false
		System.out.println(false&true);  // false
		System.out.println(false&false); // false
		

		System.out.println(true|true);   // true
		System.out.println(true|false);  // true
		System.out.println(false|true);  // true
		System.out.println(false|false); // false

		

		System.out.println(true^true);   //  false
		System.out.println(true^false);  //  true
		System.out.println(false^true);  //  true
		System.out.println(false^false); //  false
		
		System.out.println(!true);       // false
		
		System.out.println(true&&true);   // true
		System.out.println(true&&false);  // false
		System.out.println(false&&true);  // false
		System.out.println(false&&false); // false

		System.out.println(true||true);   // true
		System.out.println(true||false);  // true
		System.out.println(false||true);  // true
		System.out.println(false||false); // false
	}
}
```



位运算符可能会出现的笔试题目：

```JAVA
位运算符可能会出现的笔试题目：
 	1. 交换两个变量的值,不准出现第三方变量。
 	2. 取出一个二进制数据的指定位数。要求读取该二进制数据的低4位
		00000000-00000000-00010100-01001101
	&   00000000-00000000-00000000-00001111
	------------------------------------------
		00000000-00000000-00000000-00001101


class Demo {
	public static void main(String[] args) {
		int a = 3;
		int b = 5;
		/*
		第一种方式： 定义第三方变量。
		int temp = a;  // 3 
		a = b;         // a = 5 
		b = temp; 

		方式2：相加法， 缺点： 两个int类型的数据相加，有可能会出现超出int的表示范围。
		a = a+b;  // a =8
		b = a-b;  // b = 8 - 5 = 3
		a = a-b;  // a = 8 - 3 = 5

		方式3： 可以使用异或。 缺点： 逻辑不清晰。
		*/
		a = a^b;  // a = 3^5
		b = a^b;  // b = (3^5)^5 = 3
		a = a^b; //  a = (5^3)^3 = 5 
		System.out.println("a = " + a +" b="+b);
	}
}
```

### 移位运算符

移位运算符

+ `<<`：左移
  + 规律：一个操作数进行左移运算的时候，结果就是等于操作数`乘以2的n次方`，n就是左移 的位数.

+ `>>>`：无符号右移

  + 无符号右移与右移的区别：进行`右移`运算的时候，如果操作数是一个正数，那么`左边`的空缺位使用`0补`，如果操作数是一个负数，那么左边的空缺位使用1补。而使用`无符号右移`的时候，不管是正数还是负数都统一使用`0补`。

  > 笔试题目：使用最高的效率算出2乘以8的结果。
  >
  > ```
  > 2<<3 = 2*2^3 = 16;
  > ```

````java
class Demo {
	public static void main(String[] args){
		/*
		左移
		System.out.println(3<<1); // 6 
		System.out.println(3<<2); // 12
		System.out.println(3<<3); // 24 
		
		右移：
		*/
		System.out.println(3>>>1); // 1 
		System.out.println(3>>>2);  //0 
	}
}
````

### 三元运算符(三目运算符)

1. 格式

   ```java
   布尔表达式？值1:值2;
   ```

   

2. 三元运算符要注意的细节：
   + 使用三元运算符的时候，一定要使用该表达式返回的结果，或者是定义一个变量接收该表达式返回的结果。

```java
class Demo {
	public static void main(String[] args) {
		
		int age = 26;
		String result = age >= 18 ? "成年人":"未成年人";
		System.out.println(result);

		int a = 1;
		int b = 2;
		int c = 3;

		int result = a*b+c/2+2*(a+b)/c;
		int res = c / 2;
		System.out.println("result="+result); // 5  2+1+3/3 
		System.out.println("res="+res);       // 1
	}
}
```

### 使用异或对图片数据进行加密

```java
import java.io.*;

class ImageTest {
	public static void main(String[] args)  throws Exception {
        
		//找到图片文件
		File inFile = new File("e:\\加密的图片.jpg");
		File outFile = new File("e:\\解密的图片.jpg");

		//建立数据通道，让图片的二进制数据流入
		FileInputStream input = new FileInputStream(inFile);
		FileOutputStream output = new FileOutputStream(outFile);
        
		// 边读，把读到的数据异或一个数据，把把数据写出
		int content = 0; // 该变量是用于存储读取到的数据
		while((content = input.read()) != -1){  // 如果没有到文件的末尾，那么继续读取数据，读取                                               // 到的数据已经存储到content变量中了。
			output.write(content^12);
		}
	
		//关闭资源
		output.close();
		input.close();
	}
}
```



### 运算符优先级

| 运算符说明     | Java运算符                       |
| -------------- | -------------------------------- |
| 分割符         | .　　[]　　()　　,　　;          |
| 单目运算符     | +　　-　　~　　!　　++　　--     |
| 创建或类型转换 | new　　(type)                    |
| 乘法/除法      | *　　/　　%                      |
| 加法/减法      | +　　-                           |
| 关系           | <　　<=　　>=　　>　　instanceof |
| 等价           | ==　　!=                         |
| 按位与         | &                                |
| 按位异或       | ^                                |
| 按位或         | \|                               |
| 条件与         | &&                               |
| 条件或         | \|\|                             |
| 条件           | ?　:                             |
| 赋值           | =                                |



## 控制流程语句

### if语句

使用格式

+ 格式一： 只适用于一种情况下去使用。

  ```java
  if(判断条件){
  	符合条件执行的代码;
  }
  ```

+ 格式二：适用于两种情况下去使用

  ```java
  if(判断条件){
  	符合条件执行的代码
  }else{
  	不符合条件执行 的 代码
  }
  ```

+ 格式3： 适用于多种情况使用的

  ```java
  if(判断条件1){
  	符合条件1执行的 语句;
  }else if(判断条件2){
  	符合条件2执行 的语句;
  }else if(判断条件3){
  	符合条件3执行 的语句;
  }else if(判断条件4){
  	符合条件4执行 的语句;
  }......
      else{
  	都不符合上述 条件执行的代码...
  }
  ```

  

### switch语句

switch语句的格式：

```java
switch(选择的值){
    case 值1：
        符合值1执行的代码
        break;
    case 值2：
        符合值 2执行的代码
        break;
    case 值3：
        符合值 3执行的代码
        break;
    ......
    default: 
    	你的选择都符合上述的选项时执行的代码;
}
```

switch语句要注意的事项：

+ switch语句使用的变量只能是`byte`、 `char`、 `short`、`int`、 `String`数据类型，String数据类型是从jdk7.0的时候开始支持的。
+ case 语句中的值的数据类型必须与变量的`数据类型相同`，而且只能是`常量`或者`字面常量`。
+ witch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。
 + 当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。
 + switch 语句可以包含一个 `default` 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支`不需要 break `语句。

```java
class Demo {
	public static void main(String[] args) {
       
		int option = 13;	//定义一个变量存储你的选择
		switch(option){
			case 1:
				System.out.println("java");
				
			case 2:
				System.out.println("C#");
				
			case 3:
				System.out.println("javascript");
				
			case 4:
				System.out.println("android");
			default:
				System.out.println("你的选择有误");
		}
    }
}
```

```java
import java.util.*;
class Demo {
	public static void main(String[] args) {
		System.out.println("请输入一个月份：");
		//创建一个扫描器
		Scanner scanner = new Scanner(System.in);
		//调用扫描器的nextInt方法
		int month = scanner.nextInt();
		switch(month){
			case 3:
			case 4:
			case 5:
				System.out.println("春天");
				break;
			case 6:
			case 7:
			case 8:
				System.out.println("夏天");
				break;
			case 9:
			case 10:
			case 11:
				System.out.println("秋天");
				break;
			case 12:
			case 1:
			case 2:
				System.out.println("冬天");
				break;
			default:
				System.out.println("没有对应的季节");
				break;
		}
	}
}
```



## 循环语句

### while循环语句

while循环 语句的格式:

```java
while(循环的条件){
	循环语句；
}
```

while循环语句要注意的事项：

+ `while`循环语句一般是通过一个变量控制其循环的次数。

 	2. while循环语句的循环体代码如果只有一个语句的时候，那么可以省略大括号。但是也是不建议大家省略。

3. while循环语句的判断条件后面不能跟有分号，否则会影响到执行的效果。

```java
class Demo {
	public static void main(String[] args) {
		 int count = 0;
		 while(count<5){
			System.out.println("Hello World!");
			count++;
		 }
	}
}
```

```java
//需求： 计算1+2+3+....+ 100的总和。
class Demo {
	public static void main(String[] args) {
		int num = 1;
		int sum  = 0;	//定义一个变量用于保存每次相加的结果
		while(num<=100){
			sum = sum+num; // sum = 1  
			num++;
		}
		System.out.println("sum = "+ sum);
	}
}
```

```java
// 计算1-100,7的倍数总和。 7  14 21
class Demo {
	public static void main(String[] args){
        
		int num = 1;
		int sum = 0;	 // 定义一个变量用于保存每次相加的总和。
	
		while(num<=100){ // num = 1
			if(num%7==0){
				sum = sum+num;
			}
			num++;
		}
		System.out.println("总和是："+ sum);
	}
}
```

```java

/*
	需求： 实现猜数字游戏， 如果没有猜对可以继续输入你猜的数字，如果猜对了停止程序。
*/
import java.util.*;
class Demo {
	public static void main(String[] args) {
		// 创建一个随机数对象
		Random random = new Random();
		// 调用随机数对象的nextInt方法产生一个随机数
		int randomNum = random.nextInt(10) + 1; //要求随机数是 1~10
		// 创建一个扫描器对象
		Scanner scanner = new Scanner(System.in);
		
		while(true){
			System.out.println("请输入你要猜的数字:");
			// 调用扫描器的nextInt方法扫描一个数字
			int guessNum = scanner.nextInt();
			if (guessNum  >randomNum){
				System.out.println("猜大了..");
			}else if(guessNum < randomNum){
				System.out.println("猜小了..");	
			}else{
				System.out.println("恭喜你，猜对了`..");	
				break;
			}
		}
	}
}
```



### do while循环语句

格式

```java
do{
	// ...
}while(判断条件);
```

while循环语句与do-while循环语句的区别：

+ while循环语句是先判断后执行循环语句的，
+ do-while循环语句是先执行，后判断。不管条件是否满足`至少会执行一次`。

```java
class Demo{
	public static void main(String[] args) {
		
		/*
		int count =0; 
		while(count<5){
			System.out.println("Hello World!");     //5次
			count++;
		}
		*/

		/*
		boolean flag = false;
		while(flag){
			System.out.println("Hello World!"); //0次
		}
		*/
		
		/*
		boolean flag = false;
		do{
			System.out.println("Hello World!");   //1次
		}while(flag);
		*/

		int count = 0;
		do{
			System.out.println("hello world"); //5次
			count++;
		}while(count<5);
	}
}
```

```java
/*
	需求： 使用do-while算出1-100之间偶数的总和。
*/
class Demo {
	public static void main(String[] args) {
		int num = 1;
		int sum = 0;	//定义一个变量用于保存每次相加的总和
		do{
			if(num%2 == 0){
				sum += num;
			}
			num++;
		}while(num < 101);
		System.out.println("sum = "+ sum);
	}
}
```

### for循环语句

for循环语句的格式

```java
for(初始化语句;判断语句;循环后的语句){
	// 循环语句;
}
```

for循环语句 要注意的事项：

+ `for(;;)`这种写法 是一个死循环语句，相当于`while(true)`;

+ for循环语句的`初始化语句只会执行一次`，只是在第一次循环的时候执行而已。

+  for循环语句的循环体语句只有一句的时候，可以省略大括号不写。但是不建议省略。

  

```java
class Demo{
	public static void main(String[] args) {
		int count = 0 ;
		for(System.out.println("初始化语句A"); count<5 ;System.out.println("循环后的语句C")){
			System.out.println("循环体语句B");
			count++;
		}

		/*
            初始化语句A
            循环体语句B
            循环后的语句C
            循环体语句B
            循环后的语句C
            循环体语句B
            循环后的语句C
            循环体语句B
            循环后的语句C
            循环体语句B
            循环后的语句C
		*/

		for(count = 0 ; count<5;  count++){
			System.out.println("hello world");  //5次
		}	

		/*
		for(int count = 0 ; count<5;  count++){
			System.out.println("hello world");  //5次
		}	
		*/
	}
}
```

###  案例

#### 打印矩形

```java
/*
    需求： 在控制台上打印一个 五行五列矩形/.

        *****
        *****
        *****
        *****
        *****

    先打印一行
*/
class Demo {
	public static void main(String[] args) {
		for(int j = 0 ; j<5 ; j++){ //  控制行数
			for(int i = 0 ; i<5 ; i++){ // 控制列数
				System.out.print("*");
			}  // *****
			//换行
			System.out.println();
		}
	}
}
```

#### 打印一个正立的直角三角形

```java
/*
需求： 在控制台上打印一个正立的直角三角形 。

*
**
***
****
*****

多行多列的图形。

行数 5行

列数： 会发生变化的.

分析列数:
	i = 0 ; i<5; j=0 ; j<=i 	1个星号
	i = 1 ; i<5 ;j=0 ; j<=1 	2个星号
	i = 2 ; i<5; j=0 ; j<=2     3个星号
	.....
*/
class Demo {
	public static void main(String[] args) {
		for(int i = 0 ; i< 5 ; i++){
			for(int j = 0 ; j<=i ; j++){ // 控制列数 
				System.out.print("*");
			}
			// 换行
			System.out.println();
		}
	}
}
```

#### 打印一个倒立的直角三角形

```java
/*
需求： 打印一个倒立的直角三角形。

*****
****
***
**
*

5行

列数会发生变化
				      j<(5-i)
	i= 0 ; i<5; j=0 ; j<5;	五个星号
	i = 1; i<5; j=0 ; j<4; 	四个星号
	i = 2; i<5; j=0 ; j<3; 	三个星号
*/

class Demo {
	public static void main(String[] args) {
		for(int i = 0 ; i<5;  i++){
			for (int j = 0 ; j<(5-i)  ;j++ ){
				System.out.print("*");
			}
			// 换行
			System.out.println();
		}
	}
}
```

#### 打印一个九九乘法表

```java
/*
	需求： 打印一个九九乘法表.
*/
class Demo {
	public static void main(String[] args) {
		for(int i = 1 ; i<=9 ; i++){
			for(int j = 1 ; j<=i ; j++){ //控制列数 
				System.out.print(i + "*" + j + "=" + i*j + "\t");
			}
			//换行
			System.out.println();
		}
	}
}
```



## break和continue

### break关键字

break适用范围：只能用于`switch`或者是`循环语句`中。

break作用：

+ break用于switch语句的作用是结束一个switch语句。
+ break用于循环语句中的作用是`结束当前所在的循环语句`。



问题：break 目前位于内层的for循环，如何才能让break作用于外层 的for循环。

+ `可以标记(标签)解决`，标记的命名只要符合标识符的命名规则即可。 

```java
class Demo {
	public static void main(String[] args) {
		aaa:for(int j = 0 ; j<3 ; j++){            // j=0 外层for循环
			bbb:for(int i = 0 ; i< 2 ; i++){       // i=0 内层for循环
				System.out.println("hello world"); // 1	
				break aaa;
			}
		}
	}
}
```

### continue关键字

continue的适用范围： `continue`只能用于`循环`语句。

continue的作用：continue的作用是跳过本次的循环体内容。`继续下一次`。

continue要注意的事项：

+ 在一种情况下，continue后面不能跟有其他语句，因为是永远都无法执行到。

+ continue 也可以配合标记使用的。

```java
class Demo{
	public static void main(String[] args) {
		
		for(int i = 0 ; i<5 ; i++){   // i=1  2
			if(i==1){
				continue;
			}
			System.out.println("hello "+i);    
		}
	}
}
/*
	hello 0
    hello 2
    hello 3
    hello 4
*/
```

```java
class Demo {
	public static void main(String[] args) {
		
		outer:for(int i = 0 ; i<3; i++){       // i= 0;  i =1 i=2 3
			inner:for(int j = 0 ; j<2 ; j++){  // j=0
				System.out.println("hello j-i = " + j+"-"+i);   // 1 2 3
				continue outer;
			}
		}
	}
}
/*
    hello j-i = 0-0
    hello j-i = 0-1
    hello j-i = 0-2
*/
```

```java
class Demo {
	public static void main(String[] args) {
		int sum = 0 ;
		for(int num = 1 ; num<=100 ; num++){
			if(num%2 != 0){
				continue;  // 如果是奇数就跳过本次循环。
			}
			sum  = sum+num;
		}
		System.out.println("总和："+ sum);
	}
}
```



## 转义字符

特殊字符使用`”\”`把其转化成字符的本身输出，那么使用”\”的字符称作为转移字符。

常见的转义字符有：

+ `\b`	Backspace 退格键
+ `\t`	Tab    制表符(制表符的作用就是为了让一列对齐)  一个tab一般等于四个空格。
+ `\n`	换行
+ `\r`	回车  把光标移动到一行的首位置上。

> 注意： 如果是在windows系统上操作文件的时候需要换行，是需要`\r\n`一起使用的。
> 如果是在其他的操作系统上需要换行，仅需要`\n`即可。

```java
import java.io.*;
class Demo {
	public static void main(String[] args) throws Exception{
        
		// System.out.println("Hello\rworld!");

		File file = new File("F:\\a.txt");
		FileWriter  out = new FileWriter(file);
		out.write("大家好\r\n");
		out.write("你们好");
		out.close();
	}
}
```

## 函数（方法）

函数的作用： 提高功能代码的复用性。

### 函数的定义格式

```java
修饰符  返回值类型  函数名(形式参数...){
	// 需要被封装的功能代码；
	return 结果;
}
```

分析函数：

```java
public static int add(){
    int a =2;
    int b =3;
    return a+b;
}
```

+ `修饰符`: public static
+ `返回值类型`： int 。 返回值类型就是指函数运行完毕后，返回的结果的数据类型。
  + 注意： 某些函数是没有结果返回给调用者的,那么这时候返回值类型是void
+ `函数名`： add   函数名的作用：如果需要调用该函数就需要使用的函数名。 函数名只要符合标识符的命名规则即可。 
  + 函数名的命名规范： `首单词全部小写，其他单词的首字母大写，其他小写`。
+ `形式参数`： 如果一个函数在运行的时候，存在着数据是要调用者确定 的，那么这时候就应该定义形式参数。
+ `return `： 把一个结果返回给调用者



函数的特点：

+ 函数定义好之后，是需要被调用才会执行的。 `main函数是有jvm调用的`，不需要我们手动调用。
2. 函数的作用就是把一个功能代码给封装起来，已达到提高功能代码的`复用性`。
3. 函数定义好之后是`需要被调用`才会执行的。
4. 如果一个函数`没有返回值`返回给调用者，那么返回值类型必须是使用`void`表示。



### return关键字

return 关键字的作用：

+ 返回数据给函数的调用者。
+ 函数一旦执行到了return关键字，那么该函数马上结束。 (能结束一个函数)

break关键字与return关键字的区别：

+ `break`关键字是结束一个`循环`。
+ `return`关键字是结束一个`函数`。

> **注意：一个函数的返回值类型 是`void`，那么也可以出现`return`关键字，但是return关键字的后面不能有数据。**

```java
class Demo {

	public static void main(String[] args) {
	    // String result = getGrade(10);	//调用函数
	    // ystem.out.println("对应的等级是："+ result );
		// add(0,2);
		print();
	}

	public static void print(){
		for(int i = 0 ; i < 5;  i++){
			System.out.println("hello world");
			// break; // 结束了当前的循环
			return ;  // 结束当前的函数
		}
		System.out.println("哈哈我能执行吗??");
	}

	// 目前该函数的返回值类型是void，那么是否可以存在return关键字呢？
	public static void add(int a , int b){
		if(a==0){
			return; //结束一个函数
		}
		System.out.println("总和："+(a+b));
	}
}
```

### 方法的四种类型

1. 无参数无返回值的方法

   ```java
   // 无参数无返回值的方法(如果方法没有返回值，不能不写，必须写void，表示没有返回值)
   public void f1() {
       System.out.println("无参数无返回值的方法");
   }
   ```

2. 有参数无返回值的方法

   ```java
   /**
   * 有参数无返回值的方法
   * 参数列表由零组到多组“参数类型+形参名”组合而成，多组参数之间以英文逗号（,）隔开，形参类型和形参
   * 名之间以英文空格隔开
   */
   public void f2(int a, String b, int c) {
       System.out.println(a + "-->" + b + "-->" + c);
   }
   ```

3. 有返回值无参数的方法

   ```java
   // 有返回值无参数的方法（返回值可以是任意的类型,在函数里面必须有return关键字返回对应的类型）
   public int f3() {
       System.out.println("有返回值无参数的方法");
       return 2;
   }
   ```

4. 有返回值有参数的方法

   ```java
   // 有返回值有参数的方法
   public int f4(int a, int b) {
       return a * b;
   }
   ```

   

5. return 在无返回值方法的特殊使用

   ```java
   // return在无返回值方法的特殊使用
   public void f5(int a) {
       if (a>10) {
       	return; // 表示结束所在方法 （f5方法）的执行,下方的输出语句不会执行
   	}
       System.out.println(a);
   }
   ```

### 案例代码

```java
class Demo {
	public static void main(String[] args){
        
		//int sum = add(2,3); //调用了add名字 的函数。
		//System.out.println("结果："+ sum);
		
		add(2,3);
	}
	
/*
	// 做加法功能的函数
	// int a,int b形式参数: 形式参数的值是交给调用者确定的
	public static int add(int a,int b){ 
		return a+b;
	}
*/
    
    // 需求： 定义一个函数做加法功能，不需要返回结果给调用者，直接输出结果即可。
	public static  void add(int a ,int b){
		int sum = a+b;
		System.out.println("结果："+ sum);
	}
}
```

```java
class Demo {
	public static void main(String[] args) {
		int max = getMax(14,5); //调用了函数   实际参数
		System.out.println("最大值："+ max);
		getMax2(3,7);
	}
	
	// 需求2：定义一个函数比较两个int类型的数据大小， 不需要把最大值返回给调用者,直接打印即可。
	public static void getMax(int a, int b){
		int max = 0; //定义一个变量用于保存最大值的
		if(a>b){
			max = a;
		}else{
			max = b;
		}
		System.out.println("最大值："+ max);
	}

	//需求1： 定义一个函数比较两个int类型的数据大小， 把最大值返回给调用者。
	public static int  getMax1(int a, int b){  // 形式参数
		int max = 0; //定义一个变量用于保存最大值的
		if(a>b){
			max = a;
		}else{
			max = b;
		}
		return max;	//把结果返回给调用者
	}
}
```

```java
class Demo {
	public static void main(String[] args) {
		// String result = getGrade(189);
		// System.out.println(result);
		print(7);
	}

	// 需求2： 定义一个函数打印一个乘法表，不需要返回任何数据。 
	public static void  print(int row){
		for(int i = 1 ; i<= row ; i++){
			for (int j = 1 ;j<=i  ;j++ ){
				System.out.print(i+"*"+j+"="+i*j+"\t");
			}
			//换行
			System.out.println();
		}
	}

	//需求1： 定义一个函数判断一个分数的等级，把分数的等级返回给调用者。
	public static String getGrade2(int score){
		String grade = "";	//定义一个变量存储等级
		if(score>=90&&score<=100){
			grade = "A等级";
		}else if(score>=80&&score<=89){
			grade = "B等级";
		}else if(score>=70&&score<=79){
			grade = "C等级";
		}else if(score>=60&&score<=69){
			grade = "D等级";
		}else if(score>=0&&score<=59){
			grade = "E等级";
		}else{
			grade = "补考等级";
		}
		return grade;	//把等级返回给调用者
	}
    
    public static String  getGrade(int score){//未知的参数定义在形参中,由函数的调用者确定。
		if(score>=90&&score<=100){
			return "A等级";
		}else if(score>=80&&score<=89){
			return "B等级";
		}else if(score>=70&&score<=79){
			return "C等级";
		}else if(score>=60&&score<=69){
			return "D等级";
		}else if(score>=0&&score<=59){
			return "E等级";
		}		
	}
}
```





### 函数的重载

`函数的重载`(Overload)

+ 在一个类中出现两个或者两个以上的同名函数，这个称作为函数的重载。
+ 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理

函数重载的要求：

+ `函数名一致`。
+  **`形参列表不一致`。（参数类型不同、个数不同、顺序不同）**
+  **`与函数的返回值类型是无关的`。**
+  **`与修饰符无关`**。

> **函数重载的作用： 同一个函数名可以出现了不同的函数，以应对不同个数或者不同数据类型的参数。**
>
> 解决了在同一个类中相同功能由于参数列表不同造成**方法名不同**的问题

```java
class Demo {
	public static void main(String[] args) {
		// System.out.println("Hello World!");
		// add1(1,2);
		add(1,2.0);
	}

    // 这些函数都是在做加法运算。
	public static double add(int a, int b){
		System.out.println("两个参数的总和: "+ (a+b));
		return 3.14;
	}
	
	// 重复定义
	public static int add(int a, double b){
		System.out.println("double参数的总和: "+ (a+b));
		return 12;
	}
	
	public static void add(int a , int b , int c){
		System.out.println("三个参数的总和: "+ (a+b+c));
	}
    
	public static void add(int a , int b , int c, int d){
		System.out.println("四个参数的总和: "+ (a+b+c+d));
	}
}
```



### main函数的详解

main函数的详解

+ `public `： 公共的。 权限是最大，在任何情况下都可以访问。
  + 原因： 为了保证让jvm在任何情况下都可以访问到main方法。
+ `static`:  静态。静态可以让jvm调用main函数的时候更加的方便。不需要通过对象调用。
+ `void`:  没有返回值。因为返回的数据是给 jvm，而jvm使用这个数据是没有意义的。所以就不要了。
+ `main`: 函数名。   注意： `main并不是关键字,`只不过是jvm能识别的一个特殊的函数名而已
+ `args` ：担心某些程序在启动需要参数。

```java
import java.util.*;
class Demo {
	public static void main(String[] args) {
        
		System.out.println("数组的长度："+ args.length);
        
		for(int i = 0 ; i < args.length ; i++){
			System.out.print(args[i]+",");
		}
		Scanner scanner = new Scanner(System.in);
	}
}

// E:\smile>java Demo  1 1 1 1
// 数组的长度：4
// 1,1,1,1,
```

## 数组

### 数组定义及特点

数组是存储`同一种数据类型`数据的集合容器。

数组定义格式

+ 动态方式（指定数组的长度）

  ```java
  数据类型[]  变量名 = new 数据类型[长度];
  int[] arr = new int[3];
  ```

  + 分析数组：   

    + 左边： int[] arr    声明了一个int类型的的数组变量，变量名为arr。
      + `int `: 表示该数组容器只能存储int类型的数据。
      + `[] `： 这是一个数组类型。
      + `arr` ： 变量名.

    + 右边：new int[50]; 创建了一个长度为50的int类型数组对象。
      + `new`： 创建数组对象的关键字。
      + `int`:  表示该数组对象只能存储int类型数据。
      + `[]`： 表示是数组类型。
      + `3` : 该数组最多能存储3个数据。数组的容量。

  + 静态方式（指定数组的元素)

    ```java
    数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3...};
    int[] arr = new int[]{1,2,3,4,5};
    ```

    > 不能先声明后赋值，只能声明的同时赋值



```java
class Demo {
	public static void main(String[] args) {	
        
		// 动态初始化
		// int[] arr = new int[10];
        
		// 静态初始化
		// int[] arr = {10,20,30,40,50};
		
		int[] arr = new int[50];
		Scanner scanner = new Scanner(System.in);
		for(int i  = 0 ; i< arr.length ; i++){
			arr[i] = scanner.nextInt();
		}
	}
}
```



> **注意:**
>
> 1. 如果使用静态方式创建数组,那么系统会根据元素的个数自动计算数组的长度
>
> 2. 静态方式创建数组右边的中括号里面不能写长度
>
> 3. 静态方式的省略格式创建数组不能先声明后赋值,只能声明的同时直接赋值



数组的特点

+ 数组只能存储同一种 数据类型的数据。
+ 数组是会给存储到数组中 的元素分配一个索引值的，索引值从0开始，最大的索引值是length-1；
+ 数组一旦初始化，长度固定。
+ 数组中的元素与元素之间的内存地址是连续的。



### 数组长度及内存分析

+ 对分配到数组对象中每一个数据都分配一个编号（索引值、角标、下标）,索引值的范围是`从0开始`，最大是： `长度-1`
+ 数组的有一个`length `的属性，可以查看数组 的容量。`arr.length`

```java
class Demo {
	public static void main(String[] args) {
		//定义一个数组
		int[] arr = new int[4];
		arr[0] = 10;
		arr[1] = 30;
		arr[2] = 50;
		arr[3] = 90; 
        
		// 数组的有一个length 的属性，可以查看数组 的容量。
		// System.out.println("数组的容量："+ arr.length);	
		// System.out.println("arr[2] = "+ arr[2]);
		
		//查看数组中的所有数据。
		for(int index = 0 ; index<arr.length ; index++){
			System.out.println(arr[index]);
		}
	}
}
```

![数组的内存分析1](_media\数组的内存分析1.png)



```java
class Demo {
	public static void main(String[] args) {
		
		int[] arr1 = new int[2];
		int[] arr2 = new int[2];
		arr1[1] = 10;
		arr2[1] = 20;
		System.out.println(arr1[1]);  
        
		/*
		
		int[] arr1 = new int[2];
		arr1[1] = 100;
		int[] arr2 = arr1;
		arr1[1] = 10;
		arr2[1] = 20;
		System.out.println(arr1[1]);  // 20 20 20

		*/

	}
}
```

![数组的内存分析2](_media\数组的内存分析2.png)



### 数组中最常见异常

`NullPointerException `空指针异常

- 原因： 引用类型变量没有指向任何对象，而访问了对象的属性或者是调用了对象的方法。

`ArrayIndexOutOfBoundsException `索引值越界。

- 原因：访问了不存在的索引值。

```java
class Demo {
	public static void main(String[] args) 
	{
		/*
		
		int[] arr = new int[2];
		arr = null ;  //null 让该变量不要引用任何的对象。 不要记录任何 的内存地址。
		arr[1] = 10;
		System.out.println(arr[1]);
	
		*/

		int[] arr = new int[4];
		arr[0] = 10;
		arr[1] = 30;
		arr[2]  =40;
		arr[3] = 50;
        
		//System.out.println(arr[4]); //访问索引值为4的内存空间存储的值。
			
		for(int index = 0 ; index<=arr.length ; index++){
			System.out.print(arr[index]+",");
		}
	}
}
```



### Arrays类的常见操作

#### 排序 : sort()

```java
// *************排序 sort****************
int[] a = { 1, 3, 2, 7, 6, 5, 4, 9 };
// sort(int[] a)方法按照数字顺序排列指定的数组。
Arrays.sort(a);
System.out.println("Arrays.sort(a):");
for (int i : a) {
    System.out.print(i);
}

// 换行
System.out.println();

// sort(int[] a,int fromIndex,int toIndex)按升序排列数组的指定范围
int[] b = { 1, 3, 2, 7, 6, 5, 4, 9 };
Arrays.sort(b, 2, 6);
System.out.println("Arrays.sort(b, 2, 6):");
for (int i : b) {
    System.out.print(i);
}

// 换行
System.out.println();

int[] c = { 1, 3, 2, 7, 6, 5, 4, 9 };
// parallelSort(int[] a) 按照数字顺序排列指定的数组(并行的)。同sort方法一样也有按范围的排序
Arrays.parallelSort(c);
System.out.println("Arrays.parallelSort(c)：");
for (int i : c) {
    System.out.print(i);
}

// 换行
System.out.println();

// parallelSort给字符数组排序，sort也可以
char d[] = { 'a', 'f', 'b', 'c', 'e', 'A', 'C', 'B' };
Arrays.parallelSort(d);
System.out.println("Arrays.parallelSort(d)：");
for (char d2 : d) {
    System.out.print(d2);
}
```

可能会经常遇到对字符串排序的情况,`Arrays.sort()` 对每个字符串的特定位置进行比较，然后按照升序排序。

```java
String[] strs = { "abcdehg", "abcdefg", "abcdeag" };
Arrays.sort(strs);
System.out.println(Arrays.toString(strs));//[abcdeag, abcdefg, abcdehg]
```

#### 查找 : binarySearch()

```java
// *************查找 binarySearch()****************
char[] e = { 'a', 'f', 'b', 'c', 'e', 'A', 'C', 'B' };
// 排序后再进行二分查找，否则找不到
Arrays.sort(e);
System.out.println("Arrays.sort(e)" + Arrays.toString(e));
System.out.println("Arrays.binarySearch(e, 'c')：");
int s = Arrays.binarySearch(e, 'c');
System.out.println("字符c在数组的位置：" + s);
```

#### 比较 : equals()

```java
// *************比较 equals****************
char[] e = { 'a', 'f', 'b', 'c', 'e', 'A', 'C', 'B' };
char[] f = { 'a', 'f', 'b', 'c', 'e', 'A', 'C', 'B' };

// 元素数量相同，并且相同位置的元素相同。 另外，如果两个数组引用都是null，则它们被认为是相等的 。

// 输出true
System.out.println("Arrays.equals(e, f):" + Arrays.equals(e, f));
```



#### 填充 : fill()

```java
// *************填充fill(批量初始化)****************
int[] g = { 1, 2, 3, 3, 3, 3, 6, 6, 6 };
// 数组中所有元素重新分配值
Arrays.fill(g, 3);
System.out.println("Arrays.fill(g, 3)：");
// 输出结果：333333333
for (int i : g) {
    System.out.print(i);
}

// 换行
System.out.println();

int[] h = { 1, 2, 3, 3, 3, 3, 6, 6, };
// 数组中指定范围元素重新分配值
Arrays.fill(h, 0, 2, 9);
System.out.println("Arrays.fill(h, 0, 2, 9);：");
// 输出结果：993333666
for (int i : h) {
    System.out.print(i);
}
```



#### 转列表 : asList()

```java
// *************转列表 asList()****************
/*
* 返回由指定数组支持的固定大小的列表。
* （将返回的列表更改为“写入数组”。）该方法作为基于数组和基于集合的API之间的桥梁，
* 与Collection.toArray()相结合 。
* 返回的列表是可序列化的，并实现 RandomAccess 。
* 此方法还提供了一种方便的方式来创建一个初始化为包含几个元素的固定大小的列表如下：
*/
List<String> stooges = Arrays.asList("Larry", "Moe", "Curly");
System.out.println(stooges);
```

#### 转字符串 : toString()

```java
// *************转字符串 toString()****************

// 返回指定数组的内容的字符串表示形式。
char[] k = { 'a', 'f', 'b', 'c', 'e', 'A', 'C', 'B' };
System.out.println(Arrays.toString(k));// [a, f, b, c, e, A, C, B]
```

#### 复制 : copyOf()

```java
// *************复制 copy****************
// copyOf 方法实现数组复制,h为数组，6为复制的长度
int[] h = { 1, 2, 3, 3, 3, 3, 6, 6, 6, };
int[] i = Arrays.copyOf(h, 6);
System.out.println("Arrays.copyOf(h, 6);：");
// 输出结果：123333
for (int j : i) {
    System.out.print(j);
}

// 换行
System.out.println();

// copyOfRange将指定数组的指定范围复制到新数组中
int j[] = Arrays.copyOfRange(h, 6, 11);
System.out.println("Arrays.copyOfRange(h, 6, 11)：");
// 输出结果66600(h数组只有9个元素这里是从索引6到索引11复制所以不足的就为0)
for (int j2 : j) {
    System.out.print(j2);
}
```

###  二维数组

 二维数组就是数组中的数组。

二维数组 的定义格式：

```java
数据类型[][] 变量名 = new 数据类型[长度1][长度2];
长度1：一条烟有多少盒。
长度2： 一盒烟有多少根。
```

二维数组 的初始化方式：

+ 动态初始化:

  ```java
  数据类型[][] 变量名 = new 数据类型[长度1][长度2];
  ```

+ 静态初始化：

  ```java
  数据类型[][]  变量名 = {{元素1,元素2...},{元素1,元素2...},{元素1,元素2...}, ...}
  ```

```java
class Demo {
	public static void main(String[] args) {	
		// 定义了一个二维数组
		int[][] arr = new int[3][4];
		arr[1][1] = 100;
		/*
		System.out.println("二维数组的长度："+ arr.length);    // 3
		System.out.println("二维数组的长度："+ arr[1].length); //
		*/
		System.out.println("数组的元素："+ arr[1][1]);
	}
}
```

```java
/*
    静态初始化：
        数据类型[][]  变量名 = {{元素1,元素2...},{元素1,元素2...},{元素1,元素2...}, ...}
*/
class Demo{
	public static void main(String[] args) {
		int[][] arr = {{10,11,9},{67,12},{33,35,39,40}};
		// 遍历二维数组
		for(int i = 0;  i <arr.length ; i++){
			for(int j = 0 ; j<arr[i].length ; j++){
				System.out.print(arr[i][j]+",");
			}
			// 换行
			System.out.println();
		}
	}
}
```

### 数组排序及练习

#### 选择排序

`选择排序`(直接排序)：使用一个元素与其他 的元素挨个比较一次，符合条件交换位置。

```java
class Demo {
	
	public static void main(String[] args) {
		int[] arr = {12,5,17,8,9};  //对于5元素的数组，只需要找出4个最大值就可以排序了。
		selectSort(arr);
	}

	public static void selectSort(int[] arr){
		
		// 把最大值放在首位置。
		for(int j = 0; j<arr.length-1; j++){  //  控制的是轮数。
			for(int i = j+1 ; i<arr.length ; i++){ // 找出最大值
				if(arr[i]>arr[j]){
					//交换位置
					int temp = arr[i];
					arr[i] = arr[j];
					arr[j] = temp;
				}
			}
		}
		

/*
		// 把老二放在第二个位置
		for(int i = 2  ; i< arr.length ; i++){
			if(arr[i]>arr[1]){
				int temp = arr[i];
				arr[i] = arr[1];
				arr[1] = temp;
			}
		}
		
		// 把老三放在第三个位置
		for(int i = 3  ; i< arr.length ; i++){
			if(arr[i]>arr[2]){
				int temp = arr[i];
				arr[i] = arr[2];
				arr[2] = temp;
			}
		}

		// 把老四放在第四个位置
		for(int i = 4  ; i< arr.length ; i++){
			if(arr[i]>arr[3]){
				int temp = arr[i];
				arr[i] = arr[3];
				arr[3] = temp;
			}
		}

*/
		//遍历数组，查看效果
		System.out.print("目前的元素：");
		for (int i = 0 ; i<arr.length  ;i++){
			System.out.print(arr[i]+",");
		}
	}
}
```

#### 冒泡排序

`冒泡排序`：冒泡排序的思想就是使用相邻的两个 元素挨个比较一次，符合条件交换位置。

```java
class Demo {
	public static void main(String[] args) {
		int[] arr = {12,8,17,5,9}; // 最大的索引值: 4   容量：5 
 		bubbleSort(arr);
	}
    
	public static void bubbleSort(int[] arr){
		// 把最大值放在最后一个位置
		for(int j = 0 ; j<arr.length-1 ; j++){ //控制轮数
			for(int i = 0 ; i<arr.length-1-j  ; i++){  // 找出一个最大值  
				//相邻的元素比较
				if(arr[i]>arr[i+1]){          // 8, 12, 17, 5, 9
					int temp  = arr[i];		  // 8, 12, 5, 9, 17			
					arr[i] = arr[i+1];		  // 8, 5, 9, 12, 17	
					arr[i+1] = temp;
				}
			}
		}

/*
		// 把老二放在倒数第二个位置上。
		for(int i = 0 ;  i <arr.length-1-1 ; i++){
			if(arr[i]>arr[i+1]){
				int temp = arr[i];
				arr[i] = arr[i+1];
				arr[i+1] = temp;
			}	
		}

	
		// 把老三放在倒数第三个位置上。
		for(int i = 0 ;  i <arr.length-1-2 ; i++){
			if(arr[i]>arr[i+1]){
				int temp = arr[i];
				arr[i] = arr[i+1];
				arr[i+1] = temp;
			}	
		}

		// 把老四放在倒数第四个位置上。
		for(int i = 0 ;  i <arr.length-1-3 ; i++){
			if(arr[i]>arr[i+1]){
				int temp = arr[i];
				arr[i] = arr[i+1];
				arr[i+1] = temp;
			}	
		}

*/
		//遍历数组，查看效果
		System.out.print("目前的元素：");
		for (int i = 0 ; i<arr.length  ;i++){
			System.out.print(arr[i]+",");
		}	
	}
}
```

#### 二分(折半)

`折半查找法`(二分法): 使用前提必需是有序的数组。

```java
//需求：定义一个函数接收一个数组对象和一个要查找的目标元素，函数要返回该目标元素在
//数组中的索引值，如果目标元素不存在数组中，那么返回-1表示。
class Demo {
	public static void main(String[] args) {
		int[] arr = {12,16,19,23,54};
		// int index = searchEle(arr,23);
		int index = halfSearch(arr,116);
		System.out.println("元素所在的索引值是："+ index);
	}
		
	public static int halfSearch(int[] arr, int target){
		//定义三个变量分别记录最大、最小、中间的查找范围索引值
		int max = arr.length-1;
		int min = 0;
		int mid = (max+min)/2;
		while(true){
			if(target>arr[mid]){
				min = mid+1;
			}else if(target<arr[mid]){
				max = mid -1;
			}else{
				//找到了元素
				return mid;
			}
			//没有找到的情况
			if (max<min){
				return -1;
			}
			//重新计算中间索引值
			mid = (min+max)/2;
		}
	
	}
	public static int searchEle(int[] arr, int target){
		for(int i = 0 ; i<arr.length ; i++){
			if(arr[i]==target){
				return i;
			}
		}
		return -1;
	}
}
```

#### 翻转数组

```java
/*
需求： 定义 一个函数接收一个char类型的数组对象,然后翻转数组中的元素。
char[] arr = {'a','b','c','d','e'};
*/
class Demo {
	public static void main(String[] args) {
		char[] arr = {'a','b','c','d','e'};
		reverse(arr);
	}

	public static void reverse(char[] arr){
		for(int startIndex = 0 ,endIndex = arr.length-1 ;   startIndex<endIndex ; startIndex++,endIndex--){
			char temp = arr[startIndex];
			arr[startIndex] = arr[endIndex];
			arr[endIndex] = temp;
		}
        
		//遍历数组，查看效果
		System.out.print("目前的元素：");
		for (int i = 0 ; i<arr.length  ;i++){
			System.out.print(arr[i]+",");
		}

	}
}
```

#### 数组模拟堆栈的存储方式

```java
import java.util.Arrays;

/*
 内存泄露
 
需求：编写一个类使用数组模拟堆栈的存储方式。  

堆栈存储特点： 先进后出，后进先出。

注意： 不再使用的对象，应该不要让变量指向该对象，要让该对象尽快的被垃圾回收期回收。
 */

class StackList{

	Object[] elements;

	int index = 0 ; // 当前的索引值

	public StackList(){
		this.elements = new Object[3];
	}

	// 添加内容
	public void add(Object o){
		// 添加元素之前应该要先检查是否容量够用。
		ensureCapcity();
		elements[index++] = o;
	}

	// 出栈: 删除集合的元素，并且返回。
	public Object pop(){
		int tempIndex = --index;
		Object o = elements[tempIndex];
        // 让该位置不再 引用着指定的对象,让垃圾回收期赶快回收该垃圾。
		elements[tempIndex] = null; 
		return o;
	}

	// 检查当前的数组使用够用。
	public void ensureCapcity(){
		if(index==elements.length){
			// 计算一个新的长度
			int newLength =	elements.length*2;
			elements = Arrays.copyOf(elements, newLength);
		}
	}
	// 获取当前的元素个数
	public int size(){
		return index;
	}
}

public class Demo {
	public static void main(String[] args) {

		StackList list = new StackList();
		list.add("狗娃");
		list.add("狗剩");
		list.add("铁蛋");
		list.add("美美");
		int size = list.size();
		for(int i = 0 ; i<size ; i++){
			System.out.println(list.pop());
		}
	}
}
```

#### 编写数组的工具类

```java
//数组工具类
class ArrayTool{
	public static String toString(int[] arr){
		String result  = "";
		for(int i = 0;  i < arr.length ; i++){
			if (i==0){
				result+="["+arr[i]+",";
			}else if(i==(arr.length-1)){
				result+= arr[i]+"]";
			}else{
				result+=arr[i]+",";
			}
		}
		return result;
	}
    
	public static void sort(int[] arr){
		for(int i = 0; i < arr.length-1 ; i++){
			for(int j = i+1 ; j<arr.length ; j++){
				if(arr[i]>arr[j]){
					int temp = arr[i];
					arr[i] = arr[j];
					arr[j] = temp;
				}
			}
		}	
	}
}

class Demo {
	public static void main(String[] args) {
        
		int[] arr = {12,1,456,165};
        
		ArrayTool tool = new ArrayTool();

		ArrayTool.sort(arr);
		String info = ArrayTool.toString(arr);
		System.out.println("数组的元素："+ info);
	}
}
```

### 清空数组中的0

需求： 目前存在数组：int[] arr = {0,0,12,1,0,4,6,0} ，编写一个函数
接收该数组，然后把该数组的0清空，然后返回一个不存在0元素的数组。

```java
import java.util.*;
class Demo {
	public static void main(String[] args) {
		int[] arr = {0,0,12,1,0,4,6,0};
		arr = clearZero(arr);
		System.out.println("数组的元素："+Arrays.toString(arr));
	}

	public static  int[] clearZero(int[] arr){
		// 统计0的个数
		int count = 0;	// 定义一个变量记录0的个数
		for(int i = 0 ; i<arr.length ; i++){
			if(arr[i]==0){
				count++;
			}
		}

		// 创建一个新的数组
		int[] newArr = new int[arr.length-count];
			
		int index  = 0 ; // 新数组使用的索引值
		// 把非的数据存储到新数组中。
		for(int i = 0; i<arr.length ; i++){
			if(arr[i]!=0){
				newArr[index] = arr[i];
				index++;
			}
		}
		return newArr;
	}
}
```

